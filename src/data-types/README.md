## 데이터 타입

러스트는 타입이 고정된 언어, 코드를 작성하면서 변수가 어떤 타입을 가지는지 러스트가 추론할 수는 있지만 컴파일 시에 반드시 타입이 정해져 있음을 뜻함. 타입은 **스칼라**와 **컴파운드**로 나뉨.

타입을 명시하지 않아도 변수에 어떤 값이 대입되는지를 보고 타입을 추론할 수는 있지만 대입되는 값을 보고 타입을 추론할 수 없다면 반드시 타입을 명시해야 한다.

```rust
fn main() {
  // guess의 타입이 문자열인걸 추론할 수 있음
  let guess = "1997";
  println!("{}", guess);
  // guess의 타입이 숫자형으로 추론될 것을 기대하지만 해당 라인은
  // 컴파일이 불가능함
  let guess = "1997".parse().expect("NaN");
  println!("{}", guess);
}
```

### 정수형 리터럴

부호가 있는 타입과 부호가 없는 타입으로 나뉨. `i8` 혹은 `u8` 형식이 됨, `isize`와 `usize`의 경우 운영체제가 64비트면 64비트를 가지고 32비트면 32비트를 가지게 됨.

시각적인 구분을 위해 언더바(\_)를 사용해서 표현할 수 있음 `132_000`, 16진수는 `0xff`, 8진수는 `0o77`의 형태로 표현할 수 있음.

### 소수

부동 소수점을 표현하기 위해 `f64`와 `f32` 타입을 지원함. 기본 타입은 `f64` 이유는 현대적인 CPU에서는 서로 비슷한 속도를 내면서 더 정밀한 표현이 가능하기 때문,

### 문자

러스트에서 문자를 사용하기 위해서는 작은 따옴표를 사용해 표현한다. 문자열은 큰 따옴표를 사용한다.

### 튜플

서로 다른 타입들을 하나의 타입으로 묶는게 가능 타입스크립트의 유니언 타입과 비슷한 것 같음

```rust
fn main() {
  let union_type: (u32, f64, char) = (32, 64.4, 'Z');
  println!("{}, {}, {}", union_type.0, union_type.1, union_type.2);
  // 다른 방법
  // 자바스크립트의 구조 분해 할당이랑 비슷한 방법
  let (x, y, z) = union_type;
  println!("{}, {}, {}", x, y, z);
}
```

### 배열

러스트에서 배열은 가변적이지 않음. 어떤 원소들의 컬렉션이 고정적인 크기를 가지고 확장 혹은 축소할 일이 없다면 배열을 사용, 그렇지 않다면 벡터를 사용

배열의 요소에 접근하는 방법은 자바스크립트와 동일, 러스트에서는 배열의 크기를 벗어난 인덱스 접근을 하면 컴파일 에러를 일으키지 않고 런타임시 오류를 발생시켜 프로그램을 즉시 종료시킴.
